# HTML Rendering Documentation

## Overview

The dynamic HTML output is generated by `ChangedTree+DynamicHTML.swift` and provides an interactive view of API differences between two Xcode versions. The HTML is self-contained with embedded JSON data and client-side JavaScript rendering.

## Architecture

### Data Flow

1. **Input**: `ChangedTree` (tree structure of platform/architecture/framework/type differences)
2. **Processing**: `notableDifferences()` filters to only interesting changes
3. **Serialization**: Tree converted to JSON with snake_case keys
4. **Embedding**: JSON embedded in HTML as escaped JavaScript string
5. **Rendering**: Client-side JavaScript renders the tree interactively

### File Structure

- **Single HTML file**: All data, styles, and scripts embedded
- **No external dependencies**: Fully self-contained
- **JavaScript rendering**: Tree rendered on page load using embedded JSON

## HTML Structure

### Layout Hierarchy

```
<div id="app">
  <div class="tabs">
    <div class="tab-buttons">
      <button class="tab-button">iOS</button>
      <button class="tab-button">macOS</button>
      ...
    </div>

    <div class="tab-content">        <!-- One per platform -->
      <details>                       <!-- Platform -->
        <summary>iOS</summary>
        <details>                     <!-- Architecture -->
          <summary>arm64</summary>
          <details>                   <!-- Framework -->
            <summary>üîó FrameworkName</summary>
            <details><summary>Dependencies</summary>...</details>
            <details><summary>Precedence Groups</summary>...</details>
            <details><summary>Members</summary>...</details>
            <details><summary>Types</summary>
              <details>               <!-- Named Type with content -->
                <summary>TypeName</summary>
                <details><summary>Members</summary>...</details>
                <!-- Nested types recursively -->
              </details>
              <div>TypeName</div>     <!-- Named Type without content (leaf) -->
            </details>
          </details>
        </details>
      </details>
    </div>
  </div>
</div>
```

### Navigation

- **Platform tabs**: Top-level tabs for each platform (iOS, macOS, tvOS, watchOS, visionOS)
- **Collapsible sections**: `<details>` elements for hierarchical navigation
- **Architecture ‚Üí Framework ‚Üí Types**: Nested collapsible sections

## Rendering Logic

### Type Rendering (`renderNamedType`)

Types are rendered based on their content and change status:

1. **Checks performed**:
   - `hasMembers`: Has changed members
   - `hasTypes`: Has changed nested types
   - `hasConformanceChanges`: Conformances added/removed
   - `hasAttributeChanges`: Attributes added/removed
   - `typeChanged`: Type itself added/removed/modified

2. **Rendering decisions**:
   - **Type changed but empty**: Simple `<div>` (e.g., `extension Foo: Bar` with no members)
   - **Nothing changed**: Return empty string (filtered out)
   - **Metadata-only change**: Simple `<div>` with conformance/attribute changes inline
   - **Has content**: `<details>` with expandable members/nested types

3. **Display name**:
   - Use pre-computed `display_name` if available (includes inline HTML for changes)
   - Otherwise HTML-escape the `value.value` string

### Framework Rendering (`renderFramework`)

Frameworks are rendered only if they have changes:

1. **Checks**:
   - `hasDeps`: Changed dependencies
   - `hasMembers`: Changed framework-level members
   - `hasTypes`: Any named types present
   - `hasGroups`: Changed precedence groups

2. **Type section optimization**:
   - Render all types first into `renderedTypes`
   - Only show "Types" section if `renderedTypes` is non-empty
   - Prevents empty "Types" dropdowns when all types filter out

3. **Framework emoji**:
   - ‚ûï for added frameworks
   - „Ä∞Ô∏è for modified frameworks
   - (none) for unchanged frameworks

### Change Indicators

Changes are shown using:
- **Prefixes**: Emoji indicators for list items
  - ‚ûï `li.added:before` - Added items
  - ‚ûñ `li.removed:before` - Removed items
  - „Ä∞Ô∏è `li.modified:before` - Modified items

- **Inline styling**: Spans for inline changes
  - `<span class="added">` - Green background (#f0fff4), green text (#22863a)
  - `<span class="removed">` - Red background (#ffeef0), red text (#cb2431), strikethrough

## Display Name Generation

Display names with inline changes are pre-computed in Swift during tree traversal (`ChangedTree+Walk.swift`):

### Metadata-Only Changes

For types with ONLY conformance/attribute changes (no member/nested type changes):

1. **Strip conformances**: Remove everything after `:` from base type name
2. **Build change lists**:
   - **Conformance changes**: Show as inline spans (removed in red, added in green)
   - **Attribute changes**: Only shown if no conformance changes (to avoid redundancy)
3. **Assemble display**: `baseTypeName + conformanceChanges`

**Example**:
```
Input: struct Foo: Bar, Baz (conformance Bar removed, Baz added)
Output: "struct Foo <span class='removed'>Bar</span> <span class='added'>Baz</span>"
```

### Qualified Names for Nested Types

Nested types show their full qualified path:

1. **Traverse parent stack**: Extract type names from all parents in `activeNamedTypeStack`
2. **Extract simple names**: Use regex to strip attributes/keywords, extract just the name
3. **Join path**: `Parent1.Parent2.ChildType`

**Example**:
```
extension MobileDocumentRequest {
  struct Response { ... }
}

Displays as: "MobileDocumentRequest.Response"
```

## JSON Structure

The embedded JSON follows this schema:

```json
[
  {
    "value": {"change": "unchanged", "value": "iOS"},
    "architectures": [
      {
        "value": {"change": "unchanged", "value": "arm64"},
        "frameworks": [
          {
            "value": {"change": "modified", "value": "Foundation"},
            "dependencies": [
              {"change": "added", "value": " import Swift"}
            ],
            "members": [
              {"change": "added", "value": "func foo()"}
            ],
            "named_types": [
              {
                "value": {"change": "modified", "value": "struct Foo"},
                "display_name": "struct Foo <span class='added'>Bar</span>",
                "members": [...],
                "named_types": [...],
                "conformance_changes": [
                  {"change": "added", "value": "Bar"}
                ],
                "attribute_changes": []
              }
            ],
            "precedence_groups": []
          }
        ]
      }
    ]
  }
]
```

### Change Types

All changes use one of:
- `"unchanged"` - No difference
- `"added"` - New in target version
- `"removed"` - Removed from source version
- `"modified"` - Changed between versions

## Filtering Logic

### Tree Filtering (`notableDifferences`)

Only "interesting" items are included in the output:

1. **Framework level**: Include if has dependencies/members/types/precedenceGroups that changed
2. **Type level** (`isInteresting`):
   - Type itself changed (added/removed/modified), OR
   - Has changed members, OR
   - Has interesting nested types, OR
   - Has conformance changes, OR
   - Has attribute changes

3. **Member level**: Include if not unchanged

### HTML Rendering Filters

Additional filtering happens during JavaScript rendering:

1. **Types**: Skip if no members, no nested types, no conformance changes, no attribute changes, AND type unchanged
2. **Types section**: Only show if rendered types produce non-empty HTML
3. **Members/Dependencies/Precedence Groups**: Only show if non-empty

## Special Cases

### Extensions

Extensions are treated specially:

1. **Identity**: For extensions, conformances are PART of the identity
   - `extension Foo: Bar` and `extension Foo: Baz` are different extensions
2. **Nesting**: Extensions can contain nested types
3. **Matching**: Extensions must match on name + conformances

### Multiple Declarations

Swift allows multiple declarations of the same type with different attributes:

```swift
@frozen struct Foo: Bar { }
@unsafe @frozen struct Foo: @unsafe Bar { }
```

These are treated as DIFFERENT types because decorators differ.

### Empty Content Types

Types that changed (added/removed) but have no members/nested types are shown as simple divs rather than expandable details:

```html
<div style="padding: 0.5em;">extension Foo: Bar</div>
```

## Styling

### CSS Classes

- `.tab-button` - Platform tab buttons
- `.tab-button.active` - Active platform tab
- `.tab-content` - Platform content container
- `.tab-content.active` - Visible platform content
- `.added` - Green styling for additions
- `.removed` - Red styling with strikethrough for removals
- `.modified` - Wave emoji prefix for modifications

### Visual Hierarchy

- Nested `<details>` elements provide drill-down navigation
- Borders and padding separate sections
- Monospace font (`cat -n` style) for output consistency

## Performance Considerations

1. **JSON minification**: No pretty-printing, minimal JSON size
2. **Lazy rendering**: Only visible tabs rendered initially (future enhancement)
3. **Client-side rendering**: Offloads work from Swift to browser
4. **Single file**: No HTTP requests for assets

## Platform-Specific Filtering (@available)

Members with `@available` attributes are filtered based on the selected platform tab. Only relevant `@available` attributes are shown for each platform.

### Controls

Two filtering controls appear at the top of the page:

1. **@available filtering checkbox** (checked by default):
   - **Checked**: Members are filtered by platform, and non-matching `@available` attributes are hidden
   - **Unchecked**: All members are shown on all tabs with their complete `@available` declarations

2. **Hide attributes dropdown**:
   - Click to open a dropdown showing all `@` attributes found in the diff (alphabetically sorted)
   - Each attribute has a checkbox for easy selection
   - Check one or more attributes to hide all members/types with those attributes
   - Examples: `@objc`, `@MainActor`, `@_spi`, `@available`, etc.
   - Useful for filtering out internal/SPI declarations, actor-related changes, or availability-constrained APIs
   - Selecting `@available` will hide all declarations with availability attributes, even on matching platforms
   - The dropdown button shows the count of selected attributes (e.g., "Hide attributes (3 selected)")
   - Click outside the dropdown to close it

Both controls toggle visibility without re-rendering, preserving all `<details>` toggle states.

### Supported Platform Names

All Swift platform names are recognized and normalized:
- **Base platforms**: `iOS`, `macOS`, `tvOS`, `watchOS`, `visionOS`
- **Legacy**: `OSX` (normalized to `macOS`)
- **Special platforms**: `macCatalyst`, `DriverKit`
- **Application Extensions**: `iOSApplicationExtension`, `macOSApplicationExtension`, etc.

### Filtering Rules

1. **No @available**: Members without `@available` attributes appear on all platform tabs
2. **Single platform**: `@available(iOS 14.0, *)` appears only on iOS tab
3. **Multiple platforms**: Member appears on all matching platforms, with non-matching attributes removed
4. **Unavailable platforms**: `@available(macOS, unavailable)` hides member from macOS tab
5. **ApplicationExtension variants**: Stripped to base platform (e.g., `iOSApplicationExtension` ‚Üí `iOS`)
6. **macCatalyst**: Shows on both iOS and macOS tabs (unless marked unavailable)
7. **DriverKit**: Shows on macOS tab
8. **OSX**: Normalized to macOS

### Example

Original declaration:
```swift
@available(iOS: 26.1, *) @available(macOS, unavailable) @available(tvOS, unavailable)
extension AVCaptureSmartFramingMonitor: Observation.Observable
```

Displayed on iOS tab:
```swift
@available(iOS: 26.1, *) extension AVCaptureSmartFramingMonitor: Observation.Observable
```

Not shown on macOS, tvOS, watchOS, or visionOS tabs (marked unavailable or no matching platform).

### Implementation

Platform filtering and attribute collection are implemented client-side in JavaScript:

**Platform Filtering**:
- `extractAllAvailableAttributes()`: Parses all `@available` attributes from a declaration
- `normalizePlatformName()`: Maps variants to base platforms
- `platformMatches()`: Checks if a platform matches the current tab
- `filterMemberForPlatform()`: Determines visibility and filters out non-matching attributes

**Attribute Collection**:
- `collectAllAttributes(from: StorageTree)`: Pre-computes the complete set of all `@` attributes present in the entire tree before filtering (Swift function in `ChangedTree+DynamicHTML.swift`)
- Walks all platforms ‚Üí architectures ‚Üí frameworks ‚Üí types ‚Üí members
- Extracts attributes from both old and new values in `Change<T>` enums
- Ensures the dropdown shows all attributes that exist anywhere in the diff, not just those visible after filtering

All rendering functions (`renderMembers`, `renderNamedType`, `renderFramework`, `renderArchitecture`) pass the current platform context through the call chain and apply filtering.

## Known Issues & Fixes

### Fixed Issues

1. **Empty "Types" sections**: Now renders types first, only shows section if non-empty
2. **Duplicate nested types**: Parser now properly nests types in parent's `nestedTypes` array
3. **Conformance display redundancy**: Attribute changes not shown when conformance changes exist
4. **Missing type changes**: Types that are added/removed but empty now display correctly
5. **Platform-specific @available filtering**: Members with `@available` attributes are now filtered by platform tab
6. **Attribute parsing with nested parentheses**: Replaced regex-based attribute parsing with a proper balanced-parenthesis parser in `ChangedTree+Walk.swift`. This correctly handles attributes with nested parentheses such as:
   - `@_originallyDefinedIn(module: "SwiftUI", iOS 18.0)`
   - `@_implements(Equatable, ==(_:_:))`
   - `@_dynamicReplacement(for: subscript(_:))`
   - `@_specialize(target: myFunc(_:), where T == Int)`
   - `@abi(func abiName(x: Int) -> String)`

   The previous regex pattern `@\w+(?:\([^)]*\))?` would incorrectly match only up to the first `)` character, causing type name extraction to fail for declarations with complex attributes.

### Attribute Parsing Details

The Swift parser (`ChangedTree+Walk.swift`) uses a balanced-parenthesis parser to extract type names from full declarations. The parser must skip over all attributes (including those with nested parentheses) to find the actual type keyword and name.

**Supported attributes with arguments** (per swift-syntax `AttributeNodes.swift`):
- `@_originallyDefinedIn(module: "ModuleName", platformVersions...)` - Module migration tracking
  - Example: `@_originallyDefinedIn(module: "SwiftUI", iOS 18.0)`
- `@available(platformVersions...)` - Availability constraints
  - Example: `@available(iOS 14.0, macOS 11.0, *)`
- `@backDeployed(before: platformVersions...)` - ABI back deployment
  - Example: `@backDeployed(before: iOS 17.0)`
- `@_dynamicReplacement(for: declName)` - Dynamic replacement with nested parens
  - Example: `@_dynamicReplacement(for: subscript(_:))`
- `@_implements(Type, declName)` - Protocol requirement implementation with nested parens
  - Example: `@_implements(Equatable, ==(_:_:))`
- `@derivative(of: declName, wrt: params)` - Differentiation
  - Example: `@derivative(of: compute, wrt: x)`
- `@differentiable(kind, wrt: params, where clause)` - Differentiability
  - Example: `@differentiable(reverse, wrt: x)`
- `@objc(selectorPieces)` - Objective-C interop
  - Example: `@objc(customSelector:withArg:)`
- `@_specialize(labeledArgs, where clause)` - Generic specialization with nested parens
  - Example: `@_specialize(target: myFunc(_:), where T == Int)`
- `@specialized(where clause)` - Specialized implementation
  - Example: `@specialized(where T == Int)`
- `@_spi_available(platformVersions...)` - SPI availability
  - Example: `@_spi_available(iOS 18.0, *)`
- `@_effects(tokens...)` - Effects attribute
  - Example: `@_effects(readnone)`
- `@_documentation(visibility/metadata: value)` - Documentation metadata
  - Example: `@_documentation(visibility: private)`
- `@attached(macroArgs)` - Macro attachment
  - Example: `@attached(member, names: named(init))`
- `@freestanding(macroType)` - Freestanding macro
  - Example: `@freestanding(expression)`
- `@transpose(of: declName)` - Transpose operation
  - Example: `@transpose(of: forward)`
- `@abi(declaration)` - ABI-providing declaration with full nested function signature
  - Example: `@abi(func abiName(x: Int) -> String)`

**Parsing method**: The `skipAttribute()` function uses a balanced-parenthesis counter to handle arbitrarily nested parentheses within attribute arguments. This correctly handles complex cases like `@_implements(Equatable, ==(_:_:))` and `@abi(func foo() -> Int)` where the previous regex pattern `@\w+(?:\([^)]*\))?` would fail by matching only up to the first closing parenthesis.

### Current Behavior

1. **Unchanged content filtered**: Frameworks/types with no changes don't appear (correct)
2. **Platform/architecture combinations**: Each combination shown separately (no deduplication)
3. **Full qualified names**: Nested types show complete path to avoid ambiguity
4. **Platform filtering**: Only `@available` declarations matching the selected tab are shown
5. **Attribute filtering**: Dropdown allows hiding declarations with specific attributes
6. **Attribute argument parsing**: All attributes with complex arguments are properly parsed and displayed
